//http://twitter.github.io/scala_school/advanced-types.html

//This lesson covers:
  //1View bounds (“type classes”)
  //2Other Type Bounds
  //3Higher kinded types & ad-hoc polymorphism
  //4F-bounded polymorphism / recursive types
  //5Structural types
  //6Abstract types members
  //7Type erasures & manifests
  //8Case study: Finagle

//BK 1 View bounds (“type classes”)
//Implicit functions allow automatic conversion. 
implicit def strToInt(x: String) = x.toInt
val y: Int = "123" //This will find String => Int automatically. 
val max: Int = math.max("123", 111)


//View bounds, like `type bounds` demand such a function exists for the given type. 
// You specify a view bound with <% e.g.
//eg1: A has to be “viewable” as Int
class Container[A <% Int] { def addIt(x: A): Int = 123 + x }
val it: Int = (new Container[String]).addIt("123")

//(new Container[Float]).addIt(123.2F)--> Wrong, Not Float --> Int implicit transfer


//BK 2 Other type bounds
List(1,2).sum
// List("whoop").sum //-->Wrong, not enough arguments for method `sum`.

//Methods may ask for some kinds of specific “evidence” for a type without setting up strange objects as with Numeric. 
//Instead, you can use one of these type-relation operators:

//A =:= B	  A must be equal to B
//A <:< B	  A must be a subtype of B
//A <%< B	  A must be viewable as B

//eg2

class Container2[A](value: A) { def addIt(implicit evidence: A =:= Int) = 123 + value }
class Container3[A](value: A) { def addIt(implicit evidence: A <:< Int) = 123 + value }

(new Container2(123)).addIt
(new Container3(123)).addIt

//(new Container3("123")).addIt  //-->Wrong, no implicit evidence here.


                                



//BK 3 Generic programming with views
//In the Scala standard library, views are primarily used to implement generic functions over collections. 
//For example, the “min” function (on Seq[]), uses this technique:

//def min[B >: A](implicit cmp: Ordering[B]): A = {
//  if (isEmpty)
//    throw new UnsupportedOperationException("empty.min")
//
//  reduceLeft((x, y) => if (cmp.lteq(x, y)) x else y)
//}

//The main advantages of this are:
  //1 Items in the collections aren’t required to implement Ordered, but Ordered uses are still statically type checked.
  //2 You can define your own orderings without any additional library support:
List(1,2,3,4).min
List(1,2,3,4).min(new Ordering[Int] { def compare(a: Int, b: Int) = b compare a }) //You define your own orderings

def foo[A](implicit x: Ordered[A]) {}
//def foo[A : Ordered] {} // Scala 2.8 introduced a shorthand for threading through & accessing implicit arguments.



//BK 4 ??? not sure, what do you mean ???Higher-kinded types & ad-hoc polymorphism
trait Container4[M[_]] { def put[A](x: A): M[A]; def get[A](m: M[A]): A }
val container = new Container4[List] { def put[A](x: A) = List(x); def get[A](m: List[A]) = m.head }


//BK 5 Structural types
def foo(x: { def get: Int }) = 123 + x.get
foo(new { def get = 10 })


//BK 6  Abstract type members
trait Foo { type A; val x: A; def getX: A = x }
(new Foo { type A = Int; val x = 123 }).getX
(new Foo { type A = String; val x = "hey" }).getX


//BK 7 Type erasures & manifests

//As we know, type information is lost at compile time due to erasure. 
// Scala features Manifests, allowing us to selectively recover type information. 
// Manifests are provided as an implicit value, generated by the compiler as needed.

class MakeFoo[A](implicit manifest: Manifest[A]) { def make: A = manifest.erasure.newInstance.asInstanceOf[A] }

(new MakeFoo[String]).make











